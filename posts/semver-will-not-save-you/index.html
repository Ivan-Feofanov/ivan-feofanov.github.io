<!doctype html><html lang=ru><head><link href=https://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=generator content="Hugo 0.62.2"><title>Семантическое версионирование вас не спасет • Ivan Feofanov</title><meta name=twitter:card content="summary"><meta name=twitter:title content="Семантическое версионирование вас не спасет"><meta name=twitter:description content="Семантическое версионирование вас не спасет  это перевод статьи Semver Will Not Save You
 Популярный питоновский модуль cryptography перешел на использование Rust для низкоуровневого кода, что породило весьма эмоциональный тред на Гитхабе."><meta property="og:title" content="Семантическое версионирование вас не спасет"><meta property="og:description" content="Семантическое версионирование вас не спасет  это перевод статьи Semver Will Not Save You
 Популярный питоновский модуль cryptography перешел на использование Rust для низкоуровневого кода, что породило весьма эмоциональный тред на Гитхабе."><meta property="og:type" content="article"><meta property="og:url" content="https://ivan-feofanov.github.io/posts/semver-will-not-save-you/"><meta property="article:published_time" content="2021-07-26T00:00:00+00:00"><meta property="article:modified_time" content="2021-07-26T00:00:00+00:00"><meta property="og:site_name" content="From Urals"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/androidstudio.min.css><link rel=stylesheet href=/scss/hyde-hyde.62ea8509eba00c72d68383a4a4e5791acbd54d3a049786c3f29397b31497d446.css integrity="sha256-YuqFCeugDHLWg4OkpOV5GsvVTToEl4bD8pOXsxSX1EY="><link rel=stylesheet href=/scss/print.2744dcbf8a0b2e74f8a50e4b34e5f441be7cf93cc7de27029121c6a09f9e77bc.css integrity="sha256-J0Tcv4oLLnT4pQ5LNOX0Qb58+TzH3icCkSHGoJ+ed7w=" media=print><!--[if lt IE 9]><script src=https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js></script><script src=https://oss.maxcdn.com/respond/1.4.2/respond.min.js></script><![endif]--><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png></head><body><div class=sidebar><div class=container><div class=sidebar-about><span class=site__title><a href=https://ivan-feofanov.github.io/>Ivan Feofanov</a></span><div class=author-image><img src=https://ivan-feofanov.github.io/images/avatar.jpg alt="Author Image" class="img--circle img--headshot element--center"></div><p class=site__description>Cat's shepherd, Python, Golang and NodeJS developer</p></div><div class=collapsible-menu><input type=checkbox id=menuToggle>
<label for=menuToggle>Ivan Feofanov</label><div class=menu-content><div><ul class=sidebar-nav><li><a href=/><span>Home</span></a></li></ul></div><section class=social><a href=https://twitter.com/feofanov rel=me><i class="fab fa-twitter fa-lg" aria-hidden=true></i></a><a href=https://github.com/Ivan-Feofanov rel=me><i class="fab fa-github fa-lg" aria-hidden=true></i></a><a href=https://linkedin.com/in/ivan-feofanov rel=me><i class="fab fa-linkedin fa-lg" aria-hidden=true></i></a><a href=https://t.me/feofanov rel=me><i class="fab fa-telegram fa-lg" aria-hidden=true></i></a></section></div></div><div class=copyright>&copy; 2021 Ivan Feofanov
<a href=https://creativecommons.org/licenses/by-sa/4.0>CC BY-SA 4.0</a></div><div class=builtwith>Built with <a href=https://gohugo.io>Hugo</a> ❤️ <a href=https://github.com/htr3n/hyde-hyde>hyde-hyde</a>.</div></div></div><div class="content container"><article><header><h1>Семантическое версионирование вас не спасет</h1><div class=post__meta><i class="fas fa-calendar-alt"></i>Jul 26, 2021<br><i class="fas fa-tags"></i><a class="badge badge-tag" href=/tags/dev>dev</a>
<a class="badge badge-tag" href=/tags/translation>translation</a><br><i class="fas fa-clock"></i>10 min read</div></header><div class=post><h1 id=семантическое-версионирование-вас-не-спасет>Семантическое версионирование вас не спасет</h1><blockquote><p>это перевод статьи <a href=https://hynek.me/articles/semver-will-not-save-you/>Semver Will Not Save You</a></p></blockquote><p>Популярный питоновский модуль cryptography перешел на использование Rust для низкоуровневого кода, что породило весьма эмоциональный тред на Гитхабе. Помимо энтузиастов 32-битного оборудования 1990-х годов, была активная группа, которая требовала от разработчиков строго придерживаться сематического версионирования, утверждая, что это могло бы предотвратить все беды. Я покажу вам не только почему это неправильный подход, но и как семантическое версионирование может вам навредить.</p><p>Посвящается Алексу и Полу, которые готовы принять огонь на себя за всех нас.</p><h2 id=номера-версий>Номера версий</h2><p>Давайте начнём с того, что определим основную задачу версионирования: показывать, какая версия объекта новее другой. Это можно использовать где угодно, но мы сосредоточимся на программном обеспечении.</p><p>Софтверное сообщество привыкло интерпретировать номера версий как кортежи целых чисел, разделенные точкой, читаемые слева направо. Таким образом, 2.0 новее, чем 1.10.0, которая, в свою очередь, новее, чем 1.9.42. В сообществе Python есть <a href=https://www.python.org/dev/peps/pep-0440/>PEP 440</a>, который формализует это поведение.</p><p>И это всё, что здесь важно для статьи: номера версий это уникальные, упорядочиваемые идентификаторы релизов.</p><h2 id=семантическое-версионирование>Семантическое версионирование</h2><p>На протяжении многих лет люди пытались внести смысл в эти цифры(разумеется, из благих побуждений). Пожалуй, самый популярный подход - это семантическое версионирование. У вас есть MAJOR.MINOR.MICRO и обещание состоит в том, что пока MAJOR не изменится, ничего не сломается и вы можете спокойно обновлять свои зависимости. Если, конечно, мажорная версия не ноль - в этом случае разработчик волен делать всё, что угодно.</p><blockquote><p>К сожалению, на практике методология применяется плохо, оставляя обещания невыполненными, что влечет за собой длинный хвост непредвиденных последствий как для разработчиков, так и для пользователей.</p></blockquote><h2 id=закон-хайрама>Закон Хайрама</h2><p>Давайте начнём с нарушенных обещаний и, конечно же, на эту тему есть xkcd:
<img src=/images/workflow_2x.png alt="Hyram's law">Workflow
<em><a href=https://xkcd.com/1172/>by xkcd</a></em></p><p>Он передает один из фундаментальных законов разработки программного обеспечения:</p><blockquote><p>&ldquo;При достижении достаточного количества пользователей API уже неважно, какие его особенности вы обещали всем: для любой из возможных особенностей поведения вашей системы найдётся зависящий от неё пользователь.&rdquo; - Хайрам Райт, <a href=https://www.hyrumslaw.com/>Закон Хайрама</a></p></blockquote><p>На практике это означает следующее: даже если сопровождающий чист сердцем, чрезвычайно усерден и сверхконсервативен по отношению к критическим изменениям<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>, <strong>невозможно предсказать, каким образом изменение может повлиять на ваших пользователей</strong>.</p><p>Вы хотите заявить, что версия 3.2 каким-то образом совместима с версией 3.1, но откуда вам знать? Вы знаете, что всё работает, потому что код покрыт юнит-тестами, но наверняка при переходе на новую версию вы поменяли и тесты, раз уж изменилось поведение, но как вы можете быть уверены, что вы не удалили или не изменили необходимый кому-либо функционал?</p><blockquote><p>За почти 20 лет профессиональной разработки программного обеспечения я заметил, что количество непреднамеренных поломок из-за обновлений намного превышает количество поломок преднамеренных.</p></blockquote><p>Конечно, в этом утверждении есть нюанс. Я пишу это с точки зрения программиста на Python и Go и Python - из-за его динамической природы - гораздо чаще страдает от проблем, вызванных непреднамеренными сайд-эффектами. С другой стороны, прямо сейчас я разгребаю последствия непреднамеренной несовместимости между двумя минорными релизами библиотеки в C.</p><blockquote><p>В сущности, полагаться на то, что если разработчик не планировал ничего сломать, то обновление ничего не сломает, всё равно что полагаться на то, что в ПО не бывает багов.</p></blockquote><p>Всё это не означает, что <em>SemVer</em> плохое или бесполезное. Знать <em>намерения</em> разработчика может быть полезно - особенно, <em>когда</em> что-то ломается. Хотя бы потому, что <em>SemVer</em> это, по сути, <strong>TL;DR чейнджлога</strong>.</p><p>Что это означает на самом деле - так это то, что вы не можете полагаться на семантическое значение <em>SemVer</em> и <strong>должны рассматривать каждое обновление как потенциально опасное</strong>. Если поднятие минорной версии ещё никогда не ломало ваш продакшен, вам просто надо подождать ещё немного. В конце концов вам тоже повезет - я обещаю.</p><p>С другой стороны, я видел, как бамп мажорной версии проходил для меня без последствий вообще! <strong>Поднятие мажорной версии может лишь сообщить вам о существовании преднамеренного критического изменения, но ничего об эффекте, который оно произведёт</strong>, потому что ему не хватает для этого детальности.</p><h2 id=принимаем-ответственность>Принимаем ответственность</h2><blockquote><p>Но есть кое-что, с чем лучше разобраться, чем жить перед ним в страхе.</p><p>&ndash; Джо Аберкромби, &ldquo;Кровь и железо"</p></blockquote><p>Единственный человек, который несет ответственность за состояние вашего приложения - это вы. Ваши клиенты не поймут, если вы скажете им, что они не могут получить доступ к своим данным, потому что какой-то подросток с другого континента сломал ваше приложение, не соблюдая <em>SemVer</em> так строго, как вам того хотелось бы.</p><p>Закрепление мажорной версии не поможет вам избежать проблем, Всё, на что вы можете рассчитывать - это небольшая отсрочка, но откладывать проблемы - не лучшая идея, потому что большинство из них становятся тем хуже, чем дольше вы их игнорируете.</p><hr><p>На практике это означает, что вы должны быть <em>проактивны</em> вне зависимости от того, какая схема версионирования используется в ваших зависимостях:</p><ol><li>Используйте тесты с хорошим покрытием.</li><li>Закрепите <strong>точные</strong> версии ваших зависимостей <strong>и их зависимостей тоже</strong>. Модули в Go, Cargo в Rust и npm в JavaScript поступают так по-умолчанию. Я использую <a href=https://hynek.me/articles/python-app-deps-2018/#pip-tools--everything-old-is-new-again>pip-tools</a>, но и простой pip freeze лучше чем ничего. Вы должны отделить свои зависимости, в которых написано, например, Flask, от ваших pin-файлов, в которых указано Flask == 1.1.2, вместе с зависимостями Flask и, в идеале, их хешами. В противном случае каждая сборка - это лотерея.</li><li><strong>Регулярно</strong> пробуйте <strong>обновлять</strong> ваши зависимости до их <strong>последних версий</strong>. Существует специальный инструментарий, который поможет вам в этом.</li><li>Если тесты прошли, <strong>закрепите новые версии</strong>. Если нет, то:<ul><li>Почините и затем <strong>закрепите и закоммитьте новые версии</strong>.</li><li>Если какая-то версия зависимости сломана и мейнтейнер планирует починить её в следующем релизе, заблокируйте эту конкретную версию (например, Flask!=1.1.2, но не Flask&lt;1.1.2)</li><li>Если же намеренно были произведены изменения, ломающие обратную совместимость и при этом была поднята мажорная версия, заблокируйте её (например, Flask&lt;2), но, если только у вас нет договоренности о долгосрочной поддержке старой версии, немедленно начните адаптировать ваш код к новой версии. Или поищите альтернативные варианты.</li></ul></li><li>GOTO 3</li></ol><p>Ничего не мешает вам использовать тот же процесс для опенсорсных проектов. Сервисы вроде <a href=https://dependabot.com/>Dependabot</a> помогут вам в этом.</p><hr><p>Собственно, это всё, что вам нужно сделать, чтобы сторонние пакеты не сломали ваш проект или даже ваш бизнес. Большинство тех, кто был недоволен тем, что изменения в пакете <em>cryptography</em> сломали их билды, просто не следовали шагу №2.</p><p><strong>Схема версионирования не делает жизнь проще</strong>. Она просто помогает вам понять, была ли поломка намеренной или же нет.</p><p>Это так же справедливо для экосистем Rust или Go, в которых <em>SemVer</em> вшит в систему управления пакетами<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>. Большинство непредвиденных последствий, которые я перечислю далее, применимы и к ним тоже.</p><h2 id=непредвиденные-последствия-zerover>Непредвиденные последствия: ZeroVer</h2><p>Зачастую разработчики полагают, что они обязаны придерживаться SemVer, порой из-за незнания альтернативы, порой из-за того, что &ldquo;все так делают&rdquo; а порой - по настоятельному требованию влиятельных пользователей. И в то время как в теории SemVer обещает больше свободы(технически, вы можете ломать обратную совместимость с каждым релизом, только не забывайте бампать мажорную версию), в реальности он лишь добавляет давления и работы.</p><p>В результате этого давления мы и наблюдаем то, что в шутку называют <a href=https://0ver.org/>0-based Versioning</a>.</p><p>Я уже упоминал, что разработчик волен творить любую дичь пока мажорная версия - ноль. В итоге это приводит к тому, что разработчики привязываются к своей любимой нулевой версии навсегда.</p><p>Стандарт SemVer четко обозначает, что проект, готовый к использованию в продакшене должен быть версии 1.0. К сожалению, неприятие увеличения мажорной версии - совершенно обычное дело.<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup> Так что люди застревают в 0ver и <strong>номера версии больше ничего не значат, хотя она и заявлена как семантическая</strong>.</p><p>По сути, дистрибутив который позиционирует себя как <strong>production-ready</strong> и в то же время имеющий <strong>нулевую мажорную версию</strong> - это парадокс!</p><p>Я это говорю не для того, чтобы бросить тень на чьи-либо проекты, а для того, чтобы показать что SemVer подходит не для всех проектов и порой лишь добавляет разработчику проблем.</p><h2 id=непредвиденные-последствия-отсутствие-обновлений-безопасности>Непредвиденные последствия: Отсутствие обновлений безопасности</h2><p>Причина, по которой многие были злы на разработчиков пакета <em>cryptography</em> в том, что они были убеждены, что если уж пакет следует правилам SemVer, то достаточно закрепить мажорную версию и ничего не сломается<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>.</p><p>Как я показывал выше, &ldquo;ничего не сломается&rdquo; - это ничто иное как ложное ощущение безопасности и принятие желаемого за действительное.</p><p>На самом деле, история с закреплением версий даже хуже: <strong>Большинство опенсорс-проектов не имеют возможности поддерживать несколько мажорных веток</strong>.</p><p><img src=/images/open-source-reality.jpg alt="Open Source Reality">
<em>Open Source Reality <a href=https://www.commitstrip.com/en/2014/05/07/the-truth-behind-open-source-apps/>by CommitStrip</a></em></p><p>Таким образом, закрепление мажорной версии пакета <em>обычно</em> означает, что с того момента как пакет бампнет свою мажорную версию вы не будете получать <em>никаких</em> обновлений вообще. В случае с проектами, чувствительными к проблемам с безопасностью - вроде <em>cryptography</em> а также веб-фреймворков и их зависимостей - потенциально это может иметь <strong>катастрофические последствия</strong>.</p><p>В отличие от <em>npm</em>, в основных утилитах управления пакетами в Python нет концепции уязвимых версий, для решения этих проблем вам необходим дополнительный инструментарий. Это означает, что закрепление мажорной версии ваших зависимостей в один прекрасный день приведет к тому, что <strong>ваше приложение будет битком набито уязвимостями из <a href=https://ru.wikipedia.org/wiki/Common_Vulnerabilities_and_Exposures>CVE</a> и вы никогда об этом не узнаете</strong>. <sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup></p><h2 id=но-подождите-будет-ещё-хуже>Но подождите, будет ещё хуже!</h2><p>Если вы поддерживаете публичный проект и закрепляете мажорную версию, вы <strong>транзитивно делаете это для всех приложений, которые используют ваш пакет</strong>.</p><p>Представьте приложение, которое зависит от чудесной <em>urllib3</em> и ваш пакет тоже. Теперь, если вы закрепите версию <em>urllib3</em> на &lt;2, пользователь вашего пакета не сможет когда-либо снова получить обновление от <em>urllib3</em>, как только <em>urllib3</em> повысит свою основную версию до 2 и выше.<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup> Они могут даже не осознавать насколько серьезны их проблемы.</p><p>С другой стороны, если новая версия какой-либо зависимости ломает ваш пакет, то ваши пользователи всегда могут самостоятельно закрепить старую версию этой зависимости до тех пока, пока вы не почините проблему. <strong>Но у них нет никакой возможности повлиять, на зависимости, закрепленные вами</strong>.</p><blockquote><p>Никогда не ограничивайте мажорные версии (вроде &lt;2), если только вы не уверены, что они не работают.</p></blockquote><p>Некоторые питоновские утилиты управления пакетами адоптировали закрепление мажорной версии в стиле <em>npm</em> (^) по умолчанию, несмотря на отсутствие таких же, как у <em>npm</em>, механизмов обеспечения безопасности. Не забудьте убрать это вручную, если возможно.</p><h2 id=неожиданные-последствия-конфликт-версий>Неожиданные последствия: Конфликт версий</h2><p>Эта проблема напрямую связана с предыдущей. В языках, которые позволяют иметь только одну установленную версию зависимости закрепление мажорной версии другого пакета, который вы не контролируете без знания о том, что версия другого пакета сломана, может привести к конфликту версий, который ваши пользователи не смогут разрешить самостоятельно.</p><p><img src=/images/version-conflict.svg alt="Version Conflict">
<em>Version Conflict.</em></p><p>Но в этом случае ваши пользователи хотя бы поймут, что происходит. Впрочем, вряд ли это сильно улучшит их настроение, так что будьте готовы получить пару ласковых, пока нежитесь на тропическом курорте, тратя миллионы, заработанные на разработке и поддержке опенсорса.</p><h2 id=заключение>Заключение</h2><p>Если вы <strong>разработчик</strong> и вам <em>нравится SemVer</em> как дополнительный плюс для пользователей: дерзайте! Я здесь не для того, чтобы учить вас как тратить ваше время. В добавлении семантики в версии <em>есть</em> смысл.</p><p>Я здесь для того, чтобы сказать - использование SemVer совершенно необязательно и если это вас напрягает, или вы навечно застряли на планете 0ver(что означает, что оно вас напрягает, но вы этого не замечаете или не признаете), то рассмотрите некоторые <a href=https://calver.org/>альтернативы</a>.</p><hr><p>Как пользователь, я надеюсь, что я показал, <strong>вера</strong> в SemVer:</p><ul><li>&mldr;<strong>не предотвратит проблем</strong>. В лучшем случае, отложит их. Что ещё хуже.</li><li>&mldr;приводит к <strong>конфликтам версий</strong>, что расстраивает ваших пользователей.</li><li>&mldr;приводит к <strong>проблемам с безопасностью</strong>, что, в свою очередь, расстраивает вашего босса и ваших потребителей.</li><li>&mldr;увеличивает нагрузку на разрабочиков, что делает несчастными уже их.</li></ul><p>Существует множество известных проектов, которые выглядят как <em>SemVer</em>, но таковыми не являются: <em>Linux, Python, Django, glibc&mldr;</em> и это нормально!</p><blockquote><p>Так что пожалуйста, используйте номера версий для сортировки релизов, несите ответственность за свои билды и не требуйте от разработчиков ещё больше бесплатного труда, который принесет вам самую малую пользу - и это в лучшем случае.</p></blockquote><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>Как мейнтейнеры <a href=https://pypi.org/project/setuptools/>setuptools</a>, которые на момент написания статьи достигли версии 53.1.0. Следствием этого является то, что любой проект с однозначным номером версии, в котором не используется лазейка типа 0.x, скорее всего, достаточно слабо заботится о своем версионировании, чтобы быть истинным SemVer. <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>Добавляя foo = 1.0 в cargo.toml вы можете быть уверены, что будут установлены только пакеты серии 1.0. Бамп мажорной версии в Go означает создание нового пути импорта. Что настолько болезненно, что даже <a href=https://blog.golang.org/protobuf-apiv2>Google пытается избежать этого в своих собственных проектах</a>. <a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3 role=doc-endnote><p>Hauptversionserhöhungsangst! (боязнь увеличения основного номера версии(нем.) - прим. перев.) <a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4 role=doc-endnote><p>Довольно забавно, что изменения в системе билда, которые не влияют на публичный интерфейс фактически не нарушают правил и не требуют бампа мажорной версии - по сути, они ломают совместимость с платформами, которые <a href=https://blog.yossarian.net/2021/02/28/Weird-architectures-werent-supported-to-begin-with>никогда и не поддерживались</a> авторами - но давайте оставим это за скобками. <a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5 role=doc-endnote><p>Также имейте в виду, что многие небольшие проекты никогда не регистрируются в CVE и просто исправляют проблемы с безопасностью по мере их поступления. Таким образом, даже новые причудливые предупреждения системы безопасности GitHub вам не помогут. <a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6 role=doc-endnote><p>Это не такая серьёзная проблема для языков, вроде Rust, Go или JavaScript, где можно установить более одной версии пакета. Но у вас все еще есть проблема, что ваш пакет работает с небезопасной версией зависимости. <a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></div><div id=disqus_thread></div><script type=text/javascript>(function(){if(location.hostname==="localhost"||location.hostname==="127.0.0.1"||location.hostname===""){return;}
var dsq=document.createElement('script');dsq.type='text/javascript';dsq.async=true;var disqus_shortname='ivan-feofanov';dsq.src='//'+disqus_shortname+'.disqus.com/embed.js';(document.getElementsByTagName('head')[0]||document.getElementsByTagName('body')[0]).appendChild(dsq);})();</script><noscript>Please enable JavaScript to view the
<a href=http://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=http://disqus.com/ class=dsq-brlink>comments powered by
<span class=logo-disqus>Disqus</span></a></article></div><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','A-156930500-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script defer src=https://use.fontawesome.com/releases/v5.12.1/js/all.js integrity=sha384-ZbbbT1gw3joYkKRqh0kWyRp32UAvdqkpbLedQJSlnI8iLQcFVxaGyrOgOJiDQTTR crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js></script><script type=text/javascript>hljs.initHighlightingOnLoad();</script></body></html>